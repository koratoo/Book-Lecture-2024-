# 목차

## [▣ 13장: OAuth 2 - 권한 부여 서버 구현](#▣-13장-oauth-2-권한-부여-서버-구현)

### [13.1 맞춤형 권한 부여 서버 구현 작성](#131-맞춤형-권한-부여-서버-구현-작성)

### [13.2 사용자 관리 정의](#132-사용자-관리-정의)

### [13.3 권한 부여 서버에 클라이언트 등록](#133-권한-부여-서버에-클라이언트-등록)

### [13.4 암호 그랜트 유형 이용](#134-암호-그랜트-유형-이용)

### [13.5 승인 코드 그랜트 유형 이용](#135-승인-코드-그랜트-유형-이용)

### [13.6 클라이언트 자격 증명 그랜트 유형 이용](#136-클라이언트-자격-증명-그랜트-유형-이용)

### [13.7 갱신 토큰 그랜트 유형 이용](#137-갱신-토큰-그랜트-유형-이용)

### [요약](#요약-12)

## [▣ 14장: OAuth 2 - 리소스 서버 구현](#▣-14장-oauth-2-리소스-서버-구현)

### [14.1 리소스 서버 구현](#141-리소스-서버-구현)

### [14.2 원격으로 토큰 확인](#142-원격으로-토큰-확인)

### [14.3 JdbcTokenStore로 데이터베이스 참조 구현](#143-jdbctokenstore로-데이터베이스-참조-구현)

### [14.4 방식의 간단한 비교](#144-방식의-간단한-비교)

### [요약](#요약-13)

## [▣ 15장 OAuth 2 - JWT와 암호화 서명 사용](#▣-15장-oauth-2-jwt와-암호화-서명-사용)

### [15.1 JWT의 대칭 키로 서명된 토큰 이용](#151-jwt의-대칭-키로-서명된-토큰-이용)

#### [15.1.1 JWT 이용](#1511-jwt-이용)

#### [15.1.2 JWT를 발행하는 권한 부여 서버 구현](#1512-jwt를-발행하는-권한-부여-서버-구현)

#### [15.1.3 JWT를 이용하는 리소스 서버 구현](#1513-jwt를-이용하는-리소스-서버-구현)

### [15.2 JWT를 이용한 비대칭 키로 서명된 토큰 이용](#152-jwt를-이용한-비대칭-키로-서명된-토큰-이용)

#### [15.2.1 키 쌍 생성](#1521-키-쌍-생성)

#### [15.2.2 비밀 키를 이용하는 권한 부여 서버 구성](#1522-비밀-키를-이용하는-권한-부여-서버-구성)

#### [15.2.3 공개 키를 이용하는 리소스 서버 구현](#1523-공개-키를-이용하는-리소스-서버-구현)

#### [15.2.4 공개 키를 노출하는 엔드포인트 이용](#1524-공개-키를-노출하는-엔드포인트-이용)

### [15.3 JWT에 맞춤형 세부 정보 추가](#153-jwt에-맞춤형-세부-정보-추가)

#### [15.3.1 토큰에 맞춤형 세부 정보를 추가하도록 권한 부여 서버 구성](#1531-토큰에-맞춤형-세부-정보를-추가하도록-권한-부여-서버-구성)

#### [15.3.2 JWT의 맞춤형 세부 정보를 읽을 수 있게 리소스 서버 구성](#1532-jwt의-맞춤형-세부-정보를-읽을-수-있게-리소스-서버-구성)

### [요약](#요약-14)

## [▣ 16장: 전역 메서드 보안 - 사전 및 사후 권한 부여](#▣-16장-전역-메서드-보안-사전-및-사후-권한-부여)

### [16.1 전역 메서드 보안 활성화](#161-전역-메서드-보안-활성화)

#### [16.1.1 호출 권한 부여의 이해](#1611-호출-권한-부여의-이해)

#### [16.1.2 프로젝트에서 전역 메서드 보안 활성화](#1612-프로젝트에서-전역-메서드-보안-활성화)

### [16.2 권한과 역할에 사전 권한 부여 적용](#162-권한과-역할에-사전-권한-부여-적용)

### [16.3 사후 권한 부여 적용](#163-사후-권한-부여-적용)

### [16.4 메서드의 사용 권한 구현](#164-메서드의-사용-권한-구현)

### [요약](#요약-15)

## [▣ 17장: 전역 메서드 보안 - 사전 및 사후 필터링](#▣-17장-전역-메서드-보안-사전-및-사후-필터링)

### [17.1 메서드 권한 부여를 위한 사전 필터링 적용](#171-메서드-권한-부여를-위한-사전-필터링-적용)

### [17.2 메서드 권한 부여를 위한 사후 필터링 적용](#172-메서드-권한-부여를-위한-사후-필터링-적용)

### [17.3 스프링 데이터 리포지토리에 필터링 이용](#173-스프링-데이터-리포지토리에-필터링-이용)

### [요약](#요약-16)

## [▣ 18장 실전 - OAuth 2 애플리케이션](#▣-18장-실전-oauth-2-애플리케이션)

### [18.1 애플리케이션 시나리오](#181-애플리케이션-시나리오)

### [18.2 Keycloak을 권한 부여 서버로 구성](#182-keycloak을-권한-부여-서버로-구성)

#### [18.2.1 시스템에 클라이언트 등록](#1821-시스템에-클라이언트-등록)

#### [18.2.2 클라이언트 범위 지정](#1822-클라이언트-범위-지정)

#### [18.2.3 사용자 추가 및 액세스 토큰 얻기](#1823-사용자-추가-및-액세스-토큰-얻기)

#### [18.2.4 사용자 역할 정의](#1824-사용자-역할-정의)

### [18.3 리소스 서버 구현](#183-리소스-서버-구현)

### [18.4 애플리케이션 테스트](#184-애플리케이션-테스트)

#### [18.4.1 사용자가 자기 레코드만 추가할 수 있는지 증명](#1841-사용자가-자기-레코드만-추가할-수-있는지-증명)

#### [18.4.2 사용자가 자기 레코드만 가져올 수 있는지 증명](#1842-사용자가-자기-레코드만-가져올-수-있는지-증명)

#### [18.4.3 관리자만 레코드를 삭제할 수 있는지 증명](#1843-관리자만-레코드를-삭제할-수-있는지-증명)

### [요약](#요약-17)

## [▣ 19장: 리액티브 앱을 위한 스프링 시큐리티](#▣-19장-리액티브-앱을-위한-스프링-시큐리티)

### [19.1 리액티브 앱이란?](#191-리액티브-앱이란)

### [19.2 리액티브 앱에서의 사용자 관리](#192-리액티브-앱에서의-사용자-관리)

### [19.3 리액티브 앱에서 권한 부여 규칙 구성](#193-리액티브-앱에서-권한-부여-규칙-구성)

#### [19.3.1 리액티브 앱의 엔드포인트 계층에 권한 부여 적용](#1931-리액티브-앱의-엔드포인트-계층에-권한-부여-적용)

#### [19.3.2 리액티브 앱에 메서드 보안 적용](#1932-리액티브-앱에-메서드-보안-적용)

### [19.4 리액티브 앱과 OAuth 2](#194-리액티브-앱과-oauth-2)

### [요약](#요약-18)

## [▣ 20장: 스프링 시큐리티 테스트](#▣-20장-스프링-시큐리티-테스트)

### [20.1 모의 사용자로 테스트](#201-모의-사용자로-테스트)

### [20.2 UserDetailsService의 사용자로 테스트](#202-userdetailsservice의-사용자로-테스트)

### [20.3 맞춤형 인증 Authentication 객체를 이용한 테스트](#203-맞춤형-인증-authentication-객체를-이용한-테스트)

### [20.4 메서드 보안 테스트](#204-메서드-보안-테스트)

### [20.5 인증 테스트](#205-인증-테스트)

### [20.6 CSRF 구성 테스트](#206-csrf-구성-테스트)

### [20.7 CORS 구성 테스트](#207-cors-구성-테스트)

### [20.8 리액티브 스프링 시큐리티 구현 테스트](#208-리액티브-스프링-시큐리티-구현-테스트)

### [요약](#요약-19)

## [▣ 부록A: 스프링 부트 프로젝트 만들기](#▣-부록a-스프링-부트-프로젝트-만들기)

### [A.1 start.spring.io로 프로젝트 만들기](#a1-startspringio로-프로젝트-만들기)

### [A.2 STS(스프링 툴 스위트)로 프로젝트 만들기](#a2-sts스프링-툴-스위트로-프로젝트-만들기)
