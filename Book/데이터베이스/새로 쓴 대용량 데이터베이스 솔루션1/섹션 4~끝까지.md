# 목차

- [제 1 권](#제-1-권)

- [제4장. 인덱스 수립 전략](#제4장-인덱스-수립-전략)

  - [4.1. 인덱스의 선정 기준](#41-인덱스의-선정-기준)
    - [4.1.1. 테이블 형태별 적용 기준](#411-테이블-형태별-적용-기준)
      - [가) 적은 데이터를 가진 소형 테이블](#가-적은-데이터를-가진-소형-테이블)
      - [나) 주로 참조되는 역할을 하는 중대형 테이블](#나-주로-참조되는-역할을-하는-중대형-테이블)
      - [다) 업무의 구체적인 행위를 관리하는 중대형 테이블](#다-업무의-구체적인-행위를-관리하는-중대형-테이블)
      - [라) 저장용 대형 테이블](#라-저장용-대형-테이블)
    - [4.1.2. 분포도와 손익분기점](#412-분포도와-손익분기점)
    - [4.1.3. 인덱스 머지와 결합 인덱스 비교](#413-인덱스-머지와-결합-인덱스-비교)
    - [4.1.4. 결합 인덱스의 특징](#414-결합-인덱스의-특징)
      - [가) 분포도와 결합순서의 상관관계](#가-분포도와-결합순서의-상관관계)
      - [나) 이퀄(=)이 결합순서에 미치는 영향](#나-이퀄이-결합순서에-미치는-영향)
      - [다) IN연산자를 이용한 징검다리 효과](#다-in연산자를-이용한-징검다리-효과)
      - [라) 처리범위에 직접적인 영향을 주지 못하는 컬럼의 추가 기준](#라-처리범위에-직접적인-영향을-주지-못하는-컬럼의-추가-기준)
    - [4.1.5. 결합 인덱스의 컬럼순서 결정 기준](#415-결합-인덱스의-컬럼순서-결정-기준)
    - [4.1.6. 인덱스 선정 절차](#416-인덱스-선정-절차)
      - [가) 테이블의 액세스 형태를 최대한으로 수집](#가-테이블의-액세스-형태를-최대한으로-수집)
      - [나) 인덱스 대상 컬럼의 선정 및 분포도 조사](#나-인덱스-대상-컬럼의-선정-및-분포도-조사)
      - [다) 특수한 액세스 형태에 대한 인덱스 선정](#다-특수한-액세스-형태에-대한-인덱스-선정)
      - [라) 클러스터링 검토](#라-클러스터링-검토)
      - [마) 결합 인덱스 구성 및 순서의 결정](#마-결합-인덱스-구성-및-순서의-결정)
      - [바) 시험생성 및 테스트](#바-시험생성-및-테스트)
      - [사) 수정이 필요한 애플리케이션 조사 및 수정](#사-수정이-필요한-애플리케이션-조사-및-수정)
      - [아) 일괄적용](#아-일괄적용)
  - [4.2. 클러스터링 형태의 결정 기준](#42-클러스터링-형태의-결정-기준)
    - [4.2.1. 포괄적인 클러스터링](#421-포괄적인-클러스터링)
    - [4.2.2. 부분적인 클러스터링](#422-부분적인-클러스터링)
    - [4.2.3. 단일테이블 클러스터링](#423-단일테이블-클러스터링)
    - [4.2.4. 단위 클러스터의 크기 결정](#424-단위-클러스터의-크기-결정)
    - [4.2.5. 클러스터 사용을 위한 조치](#425-클러스터-사용을-위한-조치)

- [제2부 액세스 최적화 방안](#제2부-액세스-최적화-방안)

- [제1장. 부분범위처리(Partial range scan)](#제1장-부분범위처리partial-range-scan)

  - [1.1. 부분범위처리의 개념](#11-부분범위처리의-개념)
  - [1.2. 부분범위처리의 적용원칙](#12-부분범위처리의-적용원칙)
    - [1.2.1. 부분범위 처리의 자격](#121-부분범위-처리의-자격)
    - [1.2.2. 옵티마이져 모드에 따른 부분범위처리](#122-옵티마이져-모드에-따른-부분범위처리)
  - [1.3. 부분범위처리의 수행속도 향상원리](#13-부분범위처리의-수행속도-향상원리)
  - [1.4. 부분범위처리로의 유도](#14-부분범위처리로의-유도)
    - [1.4.1. 액세스 경로를 이용한 SORT의 대체](#141-액세스-경로를-이용한-sort의-대체)
    - [1.4.2. 인덱스만 액세스하는 부분범위처리](#142-인덱스만-액세스하는-부분범위처리)
    - [1.4.3. MIN, MAX의 처리](#143-min-max의-처리)
    - [1.4.4. FILTER형 부분범위처리](#144-filter형-부분범위처리)
    - [1.4.5. ROWNUM의 활용](#145-rownum의-활용)
    - [1.4.6. 인라인뷰를 이용한 부분범위처리](#146-인라인뷰를-이용한-부분범위처리)
    - [1.4.7. 저장형 함수를 이용한 부분범위처리](#147-저장형-함수를-이용한-부분범위처리)
    - [1.4.8. 쿼리의 분리를 이용한 부분범위처리](#148-쿼리의-분리를-이용한-부분범위처리)
    - [1.4.9. 웹 게시판에서의 부분범위처리](#149-웹-게시판에서의-부분범위처리)
      - [가) 웹 게시판 부분범위처리 사례1 (NON-UNIQUE INDEX)](#가-웹-게시판-부분범위처리-사례1-non-unique-index)
      - [나) 웹 게시판 부분범위처리 사례2 (UNIQUE INDEX)](#나-웹-게시판-부분범위처리-사례2-unique-index)
      - [다) 웹 게시판 부분범위처리 사례3 (처음-이전-다음-끝)](#다-웹-게시판-부분범위처리-사례3-처음-이전-다음-끝)
      - [라) 웹 게시판 부분범위처리 사례4 (SET 단위 처리)](#라-웹-게시판-부분범위처리-사례4-set-단위-처리)
      - [마) 웹 게시판 부분범위처리 사례5 (계층구조의 처리)](#마-웹-게시판-부분범위처리-사례5-계층구조의-처리)

- [제2장. 조인의 최적화 방안](#제2장-조인의-최적화-방안)
  - [2.1. 조인과 반복연결(loop query)의 비교](#21-조인과-반복연결loop-query의-비교)
    - [2.1.1. 전체범위 처리 방식에서의 비교](#211-전체범위-처리-방식에서의-비교)
    - [2.1.2. 부분범위 처리 방식에서의 비교](#212-부분범위-처리-방식에서의-비교)
- [2.1.2. 부분범위 처리 방식에서의 비교](#212-부분범위-처리-방식에서의-비교)
  - [2.2. 연결고리 상태가 조인에 미치는 영향](#22-연결고리-상태가-조인에-미치는-영향)
    - [2.2.1. 연결고리 정상(正常)](#221-연결고리-정상正常)
    - [2.2.2. 한쪽 연결고리 이상(異常)](#222-한쪽-연결고리-이상異常)
    - [2.2.3. 양쪽 연결고리 이상(異常)](#223-양쪽-연결고리-이상異常)
  - [2.3. 조인 종류별 특징 및 활용방안](#23-조인-종류별-특징-및-활용방안)
    - [2.3.1. Nested Loops 조인](#231-nested-loops-조인)
      - [2.3.1.1. Nested Loops 조인의 기본 개념](#2311-nested-loops-조인의-기본-개념)
        - [가) Nested-Loops 조인의 특징](#가-nested-loops-조인의-특징)
        - [나) Nested-Loops 조인의 적용기준](#나-nested-loops-조인의-적용기준)
      - [2.3.1.2. Nested Loops 조인의 순서결정](#2312-nested-loops-조인의-순서결정)
    - [2.3.2. Sort Merge 조인](#232-sort-merge-조인)
      - [가) Sort Merge 조인의 특징](#가-sort-merge-조인의-특징)
      - [나) Sort Merge 조인의 적용기준](#나-sort-merge-조인의-적용기준)
    - [2.3.3. Nested Loops 조인과 Sort Merge 조인의 비교](#233-nested-loops-조인과-sort-merge-조인의-비교)
    - [2.3.4. 해쉬(Hash) 조인](#234-해쉬hash-조인)
      - [2.3.4.1. 인-메모리 해쉬조인](#2341-인-메모리-해쉬조인)
      - [2.3.4.2. 유예 해쉬조인](#2342-유예-해쉬조인)
    - [2.3.5. 세미(Semi) 조인](#235-세미semi-조인)
      - [2.3.5.1. 세미조인의 개념 및 특징](#2351-세미조인의-개념-및-특징)
      - [2.3.5.2. 세미조인의 실행계획](#2352-세미조인의-실행계획)
        - [가) Nested Loops형 세미조인](#가-nested-loops형-세미조인)
        - [나) Sort Merge형 세미조인](#나-sort-merge형-세미조인)
        - [다) 필터(Filter) 형 세미조인](#다-필터filter-형-세미조인)
        - [라) 해쉬(Hash) 형 세미조인](#라-해쉬hash-형-세미조인)
        - [마) 부정(Anti)형 세미조인](#마-부정anti형-세미조인)
    - [2.3.6. 스타(Star) 조인](#236-스타star-조인)
    - [2.3.7. 스타변형(Star Transformation) 조인](#237-스타변형star-transformation-조인)
    - [2.3.8. 비트맵 조인 인덱스(Bitmap join index)](#238-비트맵-조인-인덱스bitmap-join-index)

## 제4장. 인덱스 수립 전략

### 4.1. 인덱스의 선정 기준

#### 4.1.1. 테이블 형태별 적용 기준

- **가) 적은 데이터를 가진 소형 테이블**
- **나) 주로 참조되는 역할을 하는 중대형 테이블**
- **다) 업무의 구체적인 행위를 관리하는 중대형 테이블**
- **라) 저장용 대형 테이블**

#### 4.1.2. 분포도와 손익분기점

#### 4.1.3. 인덱스 머지와 결합 인덱스 비교

#### 4.1.4. 결합 인덱스의 특징

- **가) 분포도와 결합순서의 상관관계**
- **나) 이퀄(=)이 결합순서에 미치는 영향**
- **다) IN연산자를 이용한 징검다리 효과**
- **라) 처리범위에 직접적인 영향을 주지 못하는 컬럼의 추가 기준**

#### 4.1.5. 결합 인덱스의 컬럼순서 결정 기준

#### 4.1.6. 인덱스 선정 절차

- **가) 테이블의 액세스 형태를 최대한으로 수집**
- **나) 인덱스 대상 컬럼의 선정 및 분포도 조사**
- **다) 특수한 액세스 형태에 대한 인덱스 선정**
- **라) 클러스터링 검토**
- **마) 결합 인덱스 구성 및 순서의 결정**
- **바) 시험생성 및 테스트**
- **사) 수정이 필요한 애플리케이션 조사 및 수정**
- **아) 일괄적용**

### 4.2. 클러스터링 형태의 결정 기준

#### 4.2.1. 포괄적인 클러스터링

#### 4.2.2. 부분적인 클러스터링

#### 4.2.3. 단일테이블 클러스터링

#### 4.2.4. 단위 클러스터의 크기 결정

#### 4.2.5. 클러스터 사용을 위한 조치

# 제2부 액세스 최적화 방안

## 제1장. 부분범위처리(Partial range scan)

### 1.1. 부분범위처리의 개념

### 1.2. 부분범위처리의 적용원칙

#### 1.2.1. 부분범위 처리의 자격

#### 1.2.2. 옵티마이져 모드에 따른 부분범위처리

### 1.3. 부분범위처리의 수행속도 향상원리

### 1.4. 부분범위처리로의 유도

#### 1.4.1. 액세스 경로를 이용한 SORT의 대체

#### 1.4.2. 인덱스만 액세스하는 부분범위처리

#### 1.4.3. MIN, MAX의 처리

#### 1.4.4. FILTER형 부분범위처리

#### 1.4.5. ROWNUM의 활용

#### 1.4.6. 인라인뷰를 이용한 부분범위처리

#### 1.4.7. 저장형 함수를 이용한 부분범위처리

#### 1.4.8. 쿼리의 분리를 이용한 부분범위처리

#### 1.4.9. 웹 게시판에서의 부분범위처리

- **가) 웹 게시판 부분범위처리 사례1 (NON-UNIQUE INDEX)**
- **나) 웹 게시판 부분범위처리 사례2 (UNIQUE INDEX)**
- **다) 웹 게시판 부분범위처리 사례3 (처음-이전-다음-끝)**
- **라) 웹 게시판 부분범위처리 사례4 (SET 단위 처리)**
- **마) 웹 게시판 부분범위처리 사례5 (계층구조의 처리)**

## 제2장. 조인의 최적화 방안

### 2.1. 조인과 반복연결(loop query)의 비교

#### 2.1.1. 전체범위 처리 방식에서의 비교

#### 2.1.2. 부분범위 처리 방식에서의 비교

### 2.2. 연결고리 상태가 조인에 미치는 영향

#### 2.2.1. 연결고리 정상(正常)

#### 2.2.2. 한쪽 연결고리 이상(異常)

#### 2.2.3. 양쪽 연결고리 이상(異常)

### 2.3. 조인 종류별 특징 및 활용방안

#### 2.3.1. Nested Loops 조인

##### 2.3.1.1. Nested Loops 조인의 기본 개념

- **가) Nested-Loops 조인의 특징**
- **나) Nested-Loops 조인의 적용기준**

##### 2.3.1.2. Nested Loops 조인의 순서결정

#### 2.3.2. Sort Merge 조인

- **가) Sort Merge 조인의 특징**
- **나) Sort Merge 조인의 적용기준**

#### 2.3.3. Nested Loops 조인과 Sort Merge 조인의 비교

#### 2.3.4. 해쉬(Hash) 조인

- **2.3.4.1. 인-메모리 해쉬조인**
- **2.3.4.2. 유예 해쉬조인**

#### 2.3.5. 세미(Semi) 조인

- **2.3.5.1. 세미조인의 개념 및 특징**
- **2.3.5.2. 세미조인의 실행계획**
  - **가) Nested Loops형 세미조인**
  - **나) Sort Merge형 세미조인**
  - **다) 필터(Filter) 형 세미조인**
  - **라) 해쉬(Hash) 형 세미조인**
  - **마) 부정(Anti)형 세미조인**

#### 2.3.6. 스타(Star) 조인

#### 2.3.7. 스타변형(Star Transformation) 조인

#### 2.3.8. 비트맵 조인 인덱스(Bitmap join index)

# 제3장. SQL의 실행계획(Explain plan)

## 3.1. SQL과 옵티마이져

### 3.1.1. 옵티마이져와 우리의 역할

### 3.1.2. 옵티마이져의 형태

#### 3.1.2.1. 규칙기준 옵티마이져

- **가) 규칙기준 옵티마이져의 단점**
- **나) 규칙기준 옵티마이져의 장점**

#### 3.1.2.2. 비용기준 옵티마이져

- **가) 비용기준 옵티마이져의 장점**
- **나) 비용기준 옵티마이져의 단점**
- **다) 옵티마이져의 발전 방향**
- **라) 통계정보 관리를 위한 제언**

#### 3.1.2.3. 옵티마이져 목표(Goal)의 선택

- **가) 옵티마이져 모드의 종류**
- **나) 옵티마이져 모드의 결정 기준**
- **다) 옵티마이져 모드와 관련된 파라메터 지정**

#### 3.1.2.4. 실행계획의 고정화(Stability)

- **가) 아우트라인의 생성과 조정**
- **나) 아우트라인의 관찰**
- **다) 옵티마이져 업그레이드 시의 적용**

#### 3.1.2.5. 옵티마이져의 한계

### 3.1.3. 옵티마이져의 최적화 절차

#### 3.1.3.1. 질의 변환기

#### 3.1.3.2. 비용 산정기

#### 3.1.3.3. 실행계획 생성기

### 3.1.4. 질의의 변환(Query Transforming)

#### 3.1.4.1. 이행성 규칙(Transitivity principle)

#### 3.1.4.2. 뷰병합(View Merging)

#### 3.1.4.3. 사용자 정의 바인드 변수의 엿보기(Peeking)

### 3.1.5. 개발자의 역할

## 3.2 실행계획의 유형

### 3.2.1. 스캔(Scan)의 기본유형

#### 3.2.1.1. 전체테이블 스캔

#### 3.2.1.2. ROWID 스캔

#### 3.2.1.3. 인덱스 스캔

- **가) 인덱스 유일 스캔(Index Unique Scan)**
- **나) 인덱스 범위 스캔(Index Range Scan)**
- **다) 인덱스 역순 범위 스캔(Index Range Scan Descending)**
- **라) 인덱스 스킵 스캔(Index Skip Scan)**
- **마) 인덱스 전체 스캔(Index Full Scan)**
- **바) 인덱스 고속 전체 스캔(Index Fast Full Scans)**

#### 3.2.1.4. B-Tree 클러스터 액세스(Cluster access)

#### 3.2.1.5. 해쉬 클러스터 액세스(Hash cluster access)

#### 3.2.1.6. 표본 테이블 액세스(Sample table scan)

### 3.2.2. 데이터 연결을 위한 실행계획

#### 3.2.2.1. 내포 조인(Nested loops Join)

#### 3.2.2.2. 정렬 병합 조인(Sort Merge Join)

#### 3.2.2.3. 해쉬 조인(Hash Join)

#### 3.2.2.4. 세미 조인(Semi Join)

#### 3.2.2.5. 카티젼 조인(Cartesian Join)

#### 3.2.2.6. 아우터 조인(Outer Join)

#### 3.2.2.7. 인덱스 조인

### 3.2.3. 연산 방식에 따른 실행계획

#### 3.2.3.1. IN-List 탐침(Iterator) 실행계획

#### 3.2.3.2. 연쇄(Concatenation) 실행계획

#### 3.2.3.3. 원격(Remote) 실행계획

#### 3.2.3.4. 정렬 처리(Sort Operation) 실행계획

#### 3.2.3.5. 집합 처리(Set Operations) 실행계획

#### 3.2.3.6. COUNT(STOPKEY) 실행계획

### 3.2.4. 비트맵(Bitmap) 실행계획

#### 3.2.4.1. 조건 연산자별 비트맵 실행계획

- **가) 동치(Equal) 비교 실행계획**
- **나) 범위(Range) 비교 실행계획**
- **다) AND 조건 실행계획**
- **라) OR 조건 실행계획**
- **마) 부등식(Not equal) 비교 실행계획**
- **바) NULL 비교 실행계획**

#### 3.2.4.2. 서브쿼리 실행계획

#### 3.2.4.3. B-Tree 인덱스와의 연합(Combine) 실행계획

### 3.2.5. 기타 특수한 목적을 처리하는 실행계획

#### 3.2.5.1. 순환(Recursive) 전개 실행계획

#### 3.2.5.2. UPDATE 서브쿼리 실행계획

#### 3.2.5.3. 특이한 형태의 실행계획

- **가) 서브쿼리 팩토링 실행계획**
- **나) 특이한 DELETE 문 서브쿼리**
- **다) 다중 테이블 입력(Multi-table Insert) 서브쿼리**
- **라) HAVING 절 서브쿼리 실행계획**
- **마) ROLLUP, CUBE, GROUPING SETS 처리 실행계획**
- **바) MERGE 문 실행계획**

## 3.3. 실행계획의 제어

### 3.3.1. 힌트(Hint)의 활용 기준

### 3.3.2. 최적화 목표(Goal) 제어 힌트

### 3.3.3. 조인 순서 조정을 위한 힌트

### 3.3.4. 조인 방법 선택용 힌트

### 3.3.5. 병렬처리 관련 힌트

### 3.3.6. 액세스 수단 선택을 위한 힌트

### 3.3.7. 퀴리형태 변형(Query Transformation)을 위한 힌트

### 3.3.8. 기타 힌트
