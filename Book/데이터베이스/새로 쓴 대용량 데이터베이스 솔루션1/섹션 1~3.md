# 목차

- [제 1 권](#제-1-권)

- [제1부 액세스 영향 요소의 이해](#제1부-액세스-영향-요소의-이해)

  - [제1장. 데이터 저장구조와 특징](#제1장-데이터-저장구조와-특징)

    - [1.1. 테이블과 인덱스의 분리형](#11-테이블과-인덱스의-분리형)
      - [1.1.1. 분리형 테이블의 구조](#111-분리형-테이블의-구조)
      - [1.1.2. 클러스터링 팩터(clustering factor)](#112-클러스터링-팩터clustering-factor)
      - [1.1.3. 분리형 테이블의 액세스 영향요소](#113-분리형-테이블의-액세스-영향요소)
        - [1.1.3.1. 넓은 범위의 액세스 처리에 대한 대처방안](#1131-넓은-범위의-액세스-처리에-대한-대처방안)
        - [1.1.3.2. 클러스터링 팩터 향상 전략](#1132-클러스터링-팩터-향상-전략)
    - [1.2. 인덱스 일체형 테이블(Index-Organized Table)](#12-인덱스-일체형-테이블index-organized-table)
      - [1.2.1. 분리형과 일체형의 비교](#121-분리형과-일체형의-비교)
      - [1.2.2. 일체형 테이블의 구조 및 특징](#122-일체형-테이블의-구조-및-특징)
      - [1.2.3. 논리적 ROWID와 물리적 주소(Physical Guess)](#123-논리적-rowid와-물리적-주소physical-guess)
      - [1.2.4. 오버플로우 영역(Overflow Area)](#124-오버플로우-영역overflow-area)
      - [1.2.5. 일체형 테이블의 생성](#125-일체형-테이블의-생성)
    - [1.3. 클러스터링 테이블](#13-클러스터링-테이블)
      - [1.3.1. 클러스터링의 테이블의 개념](#131-클러스터링의-테이블의-개념)
      - [1.3.2. 단일테이블 클러스터링](#132-단일테이블-클러스터링)
      - [1.3.3. 다중테이블 클러스터링](#133-다중테이블-클러스터링)
      - [1.3.4. 클러스터링 테이블의 비용](#134-클러스터링-테이블의-비용)
        - [가) 입력(INSERT) 시의 부하](#가-입력insert-시의-부하)
        - [나) 수정(UPDATE) 시의 부하](#나-수정update-시의-부하)
        - [다) 삭제(DELETE) 시의 부하](#다-삭제delete-시의-부하)
      - [1.3.5. 해쉬(Hash) 클러스터링](#135-해쉬hash-클러스터링)
        - [가) 해쉬 클러스터의 특징](#가-해쉬-클러스터의-특징)
        - [나) 해쉬 클러스터의 활용 범위](#나-해쉬-클러스터의-활용-범위)
        - [다) 해쉬 클러스터의 정의](#다-해쉬-클러스터의-정의)
        - [라) 단일테이블 해쉬 클러스터(Single-table hash cluster)](#라-단일테이블-해쉬-클러스터single-table-hash-cluster)

  - [제2장. 인덱스의 유형과 특징](#제2장-인덱스의-유형과-특징)

    - [2.1. B-tree 인덱스](#21-b-tree-인덱스)
      - [2.1.1. B-Tree 인덱스의 구조](#211-b-tree-인덱스의-구조)
      - [2.1.2. B-Tree 인덱스의 조작(Operation)](#212-b-tree-인덱스의-조작operation)
        - [2.1.2.1. 인덱스 생성(Creation)](#2121-인덱스-생성creation)
        - [2.1.2.2. 인덱스 블록의 분할(Split)](#2122-인덱스-블록의-분할split)
        - [2.1.2.3. 데이터의 삭제 및 갱신](#2123-데이터의-삭제-및-갱신)
        - [2.1.2.4. 인덱스를 경유한 검색](#2124-인덱스를-경유한-검색)
      - [2.1.3. 리버스키 인덱스(Reverse key index)](#213-리버스키-인덱스reverse-key-index)
    - [2.2. 비트맵(Bitmap) 인덱스](#22-비트맵bitmap-인덱스)
      - [2.2.1. 비트맵 인덱스의 탄생배경](#221-비트맵-인덱스의-탄생배경)
      - [2.2.2. 비트맵 인덱스의 구조와 특성](#222-비트맵-인덱스의-구조와-특성)
      - [2.2.3. 비트맵 인덱스의 액세스](#223-비트맵-인덱스의-액세스)
    - [2.3. 함수기반 인덱스(FBI, Function-Based Index)](#23-함수기반-인덱스fbi-function-based-index)
      - [2.3.1. 함수기반 인덱스의 개념 및 구조](#231-함수기반-인덱스의-개념-및-구조)
      - [2.3.2. 함수기반 인덱스의 제약사항](#232-함수기반-인덱스의-제약사항)
      - [2.3.3. 함수기반 인덱스의 활용](#233-함수기반-인덱스의-활용)
        - [가) 테이블 설계상의 문제를 해결](#가-테이블-설계상의-문제를-해결)
        - [나) 오류 데이터의 검색 문제를 해결](#나-오류-데이터의-검색-문제를-해결)
        - [다) 가공처리 결과의 검색](#다-가공처리-결과의-검색)
        - [라) 오브젝트 타입의 인덱스 검색](#라-오브젝트-타입의-인덱스-검색)
        - [마) 배타적 관계의 인덱스 검색](#마-배타적-관계의-인덱스-검색)

  - [제3장. SQL의 실행계획(Explain plan)](#제3장-sql의-실행계획explain-plan)

    - [3.1. SQL과 옵티마이져](#31-sql과-옵티마이져)

      - [3.1.1. 옵티마이져와 우리의 역할](#311-옵티마이져와-우리의-역할)
      - [3.1.2. 옵티마이져의 형태](#312-옵티마이져의-형태)
        - [3.1.2.1. 규칙기준 옵티마이져](#3121-규칙기준-옵티마이져)
          - [가) 규칙기준 옵티마이져의 단점](#가-규칙기준-옵티마이져의-단점)
          - [나) 규칙기준 옵티마이져의 장점](#나-규칙기준-옵티마이져의-장점)
        - [3.1.2.2. 비용기준 옵티마이져](#3122-비용기준-옵티마이져)
          - [가) 비용기준 옵티마이져의 장점](#가-비용기준-옵티마이져의-장점) - [나) 비용기준 옵티마이져의 단점](#나-비용기준-옵티마이져의-단점)
          - [다) 옵티마이져의 발전 방향](#다-옵티마이져의-발전-방향)
          - [라) 통계정보 관리를 위한 제언](#라-통계정보-관리를-위한-제언)
        - [3.1.2.3. 옵티마이져 목표(Goal)의 선택](#3123-옵티마이져-목표goal의-선택)
          - [가) 옵티마이져 모드의 종류](#가-옵티마이져-모드의-종류)
          - [나) 옵티마이져 모드의 결정 기준](#나-옵티마이져-모드의-결정-기준)
          - [다) 옵티마이져 모드와 관련된 파라메터 지정](#다-옵티마이져-모드와-관련된-파라메터-지정)
        - [3.1.2.4. 실행계획의 고정화(Stability)](#3124-실행계획의-고정화stability)
          - [가) 아우트라인의 생성과 조정](#가-아우트라인의-생성과-조정)
          - [나) 아우트라인의 관찰](#나-아우트라인의-관찰)
          - [다) 옵티마이져 업그레이드 시의 적용](#다-옵티마이져-업그레이드-시의-적용)
        - [3.1.2.5. 옵티마이져의 한계](#3125-옵티마이져의-한계)
      - [3.1.3. 옵티마이져의 최적화 절차](#313-옵티마이져의-최적화-절차)
        - [3.1.3.1. 질의 변환기](#3131-질의-변환기)
        - [3.1.3.2. 비용 산정기](#3132-비용-산정기)
        - [3.1.3.3. 실행계획 생성기](#3133-실행계획-생성기)
      - [3.1.4. 질의의 변환(Query Transforming)](#314-질의의-변환query-transforming)
        - [3.1.4.1. 이행성 규칙(Transitivity principle)](#3141-이행성-규칙transitivity-principle)
        - [3.1.4.2. 뷰병합(View Merging)](#3142-뷰병합view-merging)
        - [3.1.4.3. 사용자 정의 바인드 변수의 엿보기(Peeking)](#3143-사용자-정의-바인드-변수의-엿보기peeking)
      - [3.1.5. 개발자의 역할](#315-개발자의-역할)

    - [3.2 실행계획의 유형](#32-실행계획의-유형)

      - [3.2.1. 스캔(Scan)의 기본유형](#321-스캔scan의-기본유형)
        - [3.2.1.1. 전체테이블 스캔](#3211-전체테이블-스캔)
        - [3.2.1.2. ROWID 스캔](#3212-rowid-스캔)
        - [3.2.1.3. 인덱스 스캔](#3213-인덱스-스캔)
          - [가) 인덱스 유일 스캔(Index Unique Scan)](#가-인덱스-유일-스캔index-unique-scan)
          - [나) 인덱스 범위 스캔(Index Range Scan)](#나-인덱스-범위-스캔index-range-scan)
          - [다) 인덱스 역순 범위 스캔(Index Range Scan Descending)](#다-인덱스-역순-범위-스캔index-range-scan-descending)
          - [라) 인덱스 스킵 스캔(Index Skip Scan)](#라-인덱스-스킵-스캔index-skip-scan)
          - [마) 인덱스 전체 스캔(Index Full Scan)](#마-인덱스-전체-스캔index-full-scan)
          - [바) 인덱스 고속 전체 스캔(Index Fast Full Scans)](#바-인덱스-고속-전체-스캔index-fast-full-scans)
        - [3.2.1.4. B-Tree 클러스터 액세스(Cluster access)](#3214-b-tree-클러스터-액세스cluster-access)
        - [3.2.1.5. 해쉬 클러스터 액세스(Hash cluster access)](#3215-해쉬-클러스터-액세스hash-cluster-access)
        - [3.2.1.6. 표본 테이블 액세스(Sample table scan)](#3216-표본-테이블-액세스sample-table-scan)
      - [3.2.2. 데이터 연결을 위한 실행계획](#322-데이터-연결을-위한-실행계획)
        - [3.2.2.1. 내포 조인(Nested loops Join)](#3221-내포-조인nested-loops-join)
        - [3.2.2.2. 정렬 병합 조인(Sort Merge Join)](#3222-정렬-병합-조인sort-merge-join)
        - [3.2.2.3. 해쉬 조인(Hash Join)](#3223-해쉬-조인hash-join)
        - [3.2.2.4. 세미 조인(Semi Join)](#3224-세미-조인semi-join)
        - [3.2.2.5. 카티젼 조인(Cartesian Join)](#3225-카티젼-조인cartesian-join)
        - [3.2.2.6. 아우터 조인(Outer Join)](#3226-아우터-조인outer-join)
        - [3.2.2.7. 인덱스 조인](#3227-인덱스-조인)
      - [3.2.3. 연산 방식에 따른 실행계획](#323-연산-방식에-따른-실행계획)
        - [3.2.3.1. IN-List 탐침(Iterator) 실행계획](#3231-in-list-탐침iterator-실행계획)
        - [3.2.3.2. 연쇄(Concatenation) 실행계획](#3232-연쇄concatenation-실행계획)
        - [3.2.3.3. 원격(Remote) 실행계획](#3233-원격remote-실행계획)
        - [3.2.3.4. 정렬 처리(Sort Operation) 실행계획](#3234-정렬-처리sort-operation-실행계획)
        - [3.2.3.5. 집합 처리(Set Operations) 실행계획](#3235-집합-처리set-operations-실행계획)
        - [3.2.3.6. COUNT(STOPKEY) 실행계획](#3236-countstopkey-실행계획)
      - [3.2.4. 비트맵(Bitmap) 실행계획](#324-비트맵bitmap-실행계획)
        - [3.2.4.1. 조건 연산자별 비트맵 실행계획](#3241-조건-연산자별-비트맵-실행계획)
          - [가) 동치(Equal) 비교 실행계획](#가-동치equal-비교-실행계획)
          - [나) 범위(Range) 비교 실행계획](#나-범위range-비교-실행계획)
          - [다) AND 조건 실행계획](#다-and-조건-실행계획)
          - [라) OR 조건 실행계획](#라-or-조건-실행계획)
          - [마) 부등식(Not equal) 비교 실행계획](#마-부등식not-equal-비교-실행계획)
          - [바) NULL 비교 실행계획](#바-null-비교-실행계획)
        - [3.2.4.2. 서브쿼리 실행계획](#3242-서브쿼리-실행계획)
        - [3.2.4.3. B-Tree 인덱스와의 연합(Combine) 실행계획](#3243- [B-Tree 인덱스와의 연합(Combine) 실행계획](#b-tree-인덱스와의-연합combine-실행계획)
      - [3.2.5. 기타 특수한 목적을 처리하는 실행계획](#325-기타-특수한-목적을-처리하는-실행계획)
        - [3.2.5.1. 순환(Recursive) 전개 실행계획](#3251-순환recursive-전개-실행계획)
        - [3.2.5.2. UPDATE 서브쿼리 실행계획](#3252-update-서브쿼리-실행계획)
        - [3.2.5.3. 특이한 형태의 실행계획](#3253-특이한-형태의-실행계획)
          - [가) 서브쿼리 팩토링 실행계획](#가-서브쿼리-팩토링-실행계획)
          - [나) 특이한 DELETE 문 서브쿼리](#나-특이한-delete-문-서브쿼리)
          - [다) 다중 테이블 입력(Multi-table Insert) 서브쿼리](#다-다중-테이블-입력multi-table-insert-서브쿼리)
          - [라) HAVING 절 서브쿼리 실행계획](#라-having-절-서브쿼리-실행계획)
          - [마) ROLLUP, CUBE, GROUPING SETS 처리 실행계획](#마-rollup-cube-grouping-sets-처리-실행계획)
          - [바) MERGE 문 실행계획](#바-merge-문-실행계획)

    - [3.3. 실행계획의 제어](#33-실행계획의-제어)
      - [3.3.1. 힌트(Hint)의 활용 기준](#331-힌트hint의-활용-기준)
      - [3.3.2. 최적화 목표(Goal) 제어 힌트](#332-최적화-목표goal-제어-힌트)
      - [3.3.3. 조인 순서 조정을 위한 힌트](#333-조인-순서-조정을-위한-힌트)
      - [3.3.4. 조인 방법 선택용 힌트](#334-조인-방법-선택용-힌트)
      - [3.3.5. 병렬처리 관련 힌트](#335-병렬처리-관련-힌트)
      - [3.3.6. 액세스 수단 선택을 위한 힌트](#336-액세스-수단-선택을-위한-힌트)
      - [3.3.7. 퀴리형태 변형(Query Transformation)을 위한 힌트](#337-퀴리형태-변형query-transformation을-위한-힌트)
      - [3.3.8. 기타 힌트](#338-기타-힌트)

# 제 1 권

# 제1부 액세스 영향 요소의 이해

## 제1장. 데이터 저장구조와 특징

### 1.1. 테이블과 인덱스의 분리형

#### 1.1.1. 분리형 테이블의 구조

#### 1.1.2. 클러스터링 팩터(clustering factor)

#### 1.1.3. 분리형 테이블의 액세스 영향요소

##### 1.1.3.1. 넓은 범위의 액세스 처리에 대한 대처방안

##### 1.1.3.2. 클러스터링 팩터 향상 전략

### 1.2. 인덱스 일체형 테이블(Index-Organized Table)

#### 1.2.1. 분리형과 일체형의 비교

#### 1.2.2. 일체형 테이블의 구조 및 특징

#### 1.2.3. 논리적 ROWID와 물리적 주소(Physical Guess)

#### 1.2.4. 오버플로우 영역(Overflow Area)

#### 1.2.5. 일체형 테이블의 생성

### 1.3. 클러스터링 테이블

#### 1.3.1. 클러스터링의 테이블의 개념

#### 1.3.2. 단일테이블 클러스터링

#### 1.3.3. 다중테이블 클러스터링

#### 1.3.4. 클러스터링 테이블의 비용

##### 가) 입력(INSERT) 시의 부하

##### 나) 수정(UPDATE) 시의 부하

##### 다) 삭제(DELETE) 시의 부하

#### 1.3.5. 해쉬(Hash) 클러스터링

##### 가) 해쉬 클러스터의 특징

##### 나) 해쉬 클러스터의 활용 범위

##### 다) 해쉬 클러스터의 정의

##### 라) 단일테이블 해쉬 클# 클러스터(single-table hash cluster)

## 제2장. 인덱스의 유형과 특징

### 2.1. B-tree 인덱스

#### 2.1.1. B-Tree 인덱스의 구조

#### 2.1.2. B-Tree 인덱스의 조작(Operation)

##### 2.1.2.1. 인덱스 생성(Creation)

##### 2.1.2.2. 인덱스 블록의 분할(Split)

##### 2.1.2.3. 데이터의 삭제 및 갱신

##### 2.1.2.4. 인덱스를 경유한 검색

#### 2.1.3. 리버스키 인덱스(Reverse key index)

### 2.2. 비트맵(Bitmap) 인덱스

#### 2.2.1. 비트맵 인덱스의 탄생배경

#### 2.2.2. 비트맵 인덱스의 구조와 특성

#### 2.2.3. 비트맵 인덱스의 액세스

### 2.3. 함수기반 인덱스(FBI, Function-Based Index)

#### 2.3.1. 함수기반 인덱스의 개념 및 구조

#### 2.3.2. 함수기반 인덱스의 제약사항

#### 2.3.3. 함수기반 인덱스의 활용

##### 가) 테이블 설계상의 문제를 해결

##### 나) 오류 데이터의 검색 문제를 해결

##### 다) 가공처리 결과의 검색

##### 라) 오브젝트 타입의 인덱스 검색

##### 마) 배타적 관계의 인덱스 검색

## 제3장. SQL의 실행계획(Explain plan)

### 3.1. SQL과 옵티마이져

#### 3.1.1. 옵티마이져와 우리의 역할

#### 3.1.2. 옵티마이져의 형태

##### 3.1.2.1. 규칙기준 옵티마이져

###### 가) 규칙기준 옵티마이져의 단점

###### 나) 규칙기준 옵티마이져의 장점

##### 3.1.2.2. 비용기준 옵티마이져

###### 가) 비용기준 옵티마이져의 장점

###### 나) 비용기준 옵티마이져의 단점

###### 다) 옵티마이져의 발전 방향

###### 라) 통계정보 관리를 위한 제언

##### 3.1.2.3. 옵티마이져 목표(Goal)의 선택

###### 가) 옵티마이져 모드의 종류

###### 나) 옵티마이져 모드의 결정 기준

###### 다) 옵티마이져 모드와 관련된 파라메터 지정

##### 3.1.2.4. 실행계획의 고정화(Stability)

###### 가) 아우트라인의 생성과 조정

###### 나) 아우트라인의 관찰

###### 다) 옵티마이져 업그레이드 시의 적용

##### 3.1.2.5. 옵티마이져의 한계

#### 3.1.3. 옵티마이져의 최적화 절차

##### 3.1.3.1. 질의 변환기

##### 3.1.3.2. 비용 산정기

##### 3.1.3.3. 실행계획 생성기

#### 3.1.4. 질의의 변환(Query Transforming)

##### 3.1.4.1. 이행성 규칙(Transitivity principle)

##### 3.1.4.2. 뷰병합(View Merging)

##### 3.1.4.3. 사용자 정의 바인드 변수의 엿보기(Peeking)

#### 3.1.5. 개발자의 역할

### 3.2 실행계획의 유형

#### 3.2.1. 스캔(Scan)의 기본유형

##### 3.2.1.1. 전체테이블 스캔

##### 3.2.1.2. ROWID 스캔

##### 3.2.1.3. 인덱스 스캔

###### 가) 인덱스 유일 스캔(Index Unique Scan)

###### 나) 인덱스 범위 스캔(Index Range Scan)

###### 다) 인덱스 역순 범위 스캔(Index Range Scan Descending)

###### 라) 인덱스 스킵 스캔(Index Skip Scan)

###### 마) 인덱스 전체 스캔(Index Full Scan)

###### 바) 인덱스 고속 전체 스캔(Index Fast Full Scans)

##### 3.2.1.4. B-Tree 클러스터 액세스(Cluster access)

##### 3.2.1.5. 해쉬 클러스터 액세스(Hash cluster access)

##### 3.2.1.6. 표본 테이블 액세스(Sample table scan)

#### 3.2.2. 데이터 연결을 위한 실행계획

##### 3.2.2.1. 내포 조인(Nested loops Join)

##### 3.2.2.2. 정렬 병합 조인(Sort Merge Join)

##### 3.2.2.3. 해쉬 조인(Hash Join)

##### 3.2.2.4. 세미 조인(Semi Join)

##### 3.2.2.5. 카티젼 조인(Cartesian Join)

##### 3.2.2.6. 아우터 조인(Outer Join)

##### 3.2.2.7. 인덱스 조인

#### 3.2.3. 연산 방식에 따른 실행계획

##### 3.2.3.1. IN-List 탐침(Iterator) 실행계획

##### 3.2.3.2. 연쇄(Concatenation) 실행계획

##### 3.2.3.3. 원격(Remote) 실행계획

##### 3.2.3.4. 정렬 처리(Sort Operation) 실행계획

##### 3.2.3.5. 집합 처리(Set Operations) 실행계획

##### 3.2.3.6. COUNT(STOPKEY) 실행계획

#### 3.2.4. 비트맵(Bitmap) 실행계획

##### 3.2.4.1. 조건 연산자별 비트맵 실행계획

###### 가) 동치(Equal) 비교 실행계획

###### 나) 범위(Range) 비교 실행계획

###### 다) AND 조건 실행계획

###### 라) OR 조건 실행계획

###### 마) 부등식(Not equal) 비교 실행계획

###### 바) NULL 비교 실행계획

##### 3.2.4.2. 서브쿼리 실행계획

##### 3.2.4.3. B-Tree 인덱스와의 연합(Combine) 실행계획

#### 3.2.5. 기타 특수한 목적을 처리하는 실행계획

##### 3.2.5.1. 순환(Recursive) 전개 실행계획

##### 3.2.5.2. UPDATE 서브쿼리 실행계획

##### 3.2.5.3. 특이한 형태의 실행계획

###### 가) 서브쿼리 팩토링 실행계획

###### 나) 특이한 DELETE 문 서브쿼리

###### 다) 다중 테이블 입력(Multi-table Insert) 서브쿼리

###### 라) HAVING 절 서브쿼리 실행계획

###### 마) ROLLUP, CUBE, GROUPING SETS 처리 실행계획

###### 바) MERGE 문 실행계획

### 3.3. 실행계획의 제어

#### 3.3.1. 힌트(Hint)의 활용 기준

#### 3.3.2. 최적화 목표(Goal) 제어 힌트

#### 3.3.3. 조인 순서 조정을 위한 힌트

#### 3.3.4. 조인 방법 선택용 힌트

#### 3.3.5. 병렬처리 관련 힌트

#### 3.3.6. 액세스 수단 선택을 위한 힌트

#### 3.3.7. 퀴리형태 변형(Query Transformation)을 위한 힌트

#### 3.3.8. 기타 힌트
