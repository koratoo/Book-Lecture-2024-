### [PART V 개선된 자바 동시성](#part-v-개선된-자바-동시성)

### [CHAPTER 15 CompletableFuture와 리액티브 프로그래밍 컨셉의 기초](#chapter-15-completablefuture와-리액티브-프로그래밍-컨셉의-기초)

- [15.1 동시성을 구현하는 자바 지원의 진화](#151-동시성을-구현하는-자바-지원의-진화)
- [15.2 동기 API와 비동기 API](#152-동기-api와-비동기-api)
- [15.3 박스와 채널 모델](#153-박스와-채널-모델)
- [15.4 CompletableFuture와 콤비네이터를 이용한 동시성](#154-completablefuture와-콤비네이터를-이용한-동시성)
- [15.5 발행-구독 그리고 리액티브 프로그래밍](#155-발행-구독-그리고-리액티브-프로그래밍)
- [15.6 리액티브 시스템 vs 리액티브 프로그래밍](#156-리액티브-시스템-vs-리액티브-프로그래밍)
- [15.7 마치며](#157-마치며)

### [CHAPTER 16 CompletableFuture : 안정적 비동기 프로그래밍](#chapter-16-completablefuture--안정적-비동기-프로그래밍)

- [16.1 Future의 단순 활용](#161-future의-단순-활용)
- [16.2 비동기 API 구현](#162-비동기-api-구현)
- [16.3 비블록 코드 만들기](#163-비블록-코드-만들기)
- [16.4 비동기 작업 파이프라인 만들기](#164-비동기-작업-파이프라인-만들기)
- [16.5 CompletableFuture의 종료에 대응하는 방법](#165-completablefuture의-종료에-대응하는-방법)
- [16.6 로드맵](#166-로드맵)
- [16.7 마치며](#167-마치며)

### [CHAPTER 17 리액티브 프로그래밍](#chapter-17-리액티브-프로그래밍)

- [17.1 리액티브 매니패스토](#171-리액티브-매니패스토)
- [17.2 리액티브 스트림과 플로 API](#172-리액티브-스트림과-플로-api)
- [17.3 리액티브 라이브러리 RxJava 사용하기](#173-리액티브-라이브러리-rxjava-사용하기)
- [17.4 마치며](#174-마치며)

### [PART VI 함수형 프로그래밍과 자바 진화의 미래](#part-vi-함수형-프로그래밍과-자바-진화의-미래)

### [CHAPTER 18 함수형 관점으로 생각하기](#chapter-18-함수형-관점으로-생각하기)

- [18.1 시스템 구현과 유지보수](#181-시스템-구현과-유지보수)
- [18.2 함수형 프로그래밍이란 무엇인가?](#182-함수형-프로그래밍이란-무엇인가)
- [18.3 재귀와 반복](#183-재귀와-반복)
- [18.4 마치며](#184-마치며)

### [CHAPTER 19 함수형 프로그래밍 기법](#chapter-19-함수형-프로그래밍-기법)

- [19.1 함수는 모든 곳에 존재한다](#191-함수는-모든-곳에-존재한다)
- [19.2 영속 자료구조](#192-영속-자료구조)
- [19.3 스트림과 게으른 평가](#193-스트림과-게으른-평가)
- [19.4 패턴 매칭](#194-패턴-매칭)
- [19.5 기타 정보](#195-기타-정보)
- [19.6 마치며](#196-마치며)

### [CHAPTER 20 OOP와 FP의 조화 : 자바와 스칼라 비교](#chapter-20-oop와-fp의-조화--자바와-스칼라-비교)

- [20.1 스칼라 소개](#201-스칼라-소개)
- [20.2 함수](#202-함수)
- [20.3 클래스와 트레이트](#203-클래스와-트레이트)
- [20.4 마치며](#204-마치며)

### [CHAPTER 21 결론 그리고 자바의 미래](#chapter-21-결론-그리고-자바의-미래)

- [21.1 자바 8의 기능 리뷰](#211-자바-8의-기능-리뷰)
- [21.2 자바 9 모듈 시스템](#212-자바-9-모듈-시스템)
- [21.3 자바 10 지역 변수형 추론](#213-자바-10-지역-변수형-추론)
- [21.4 자바의 미래](#214-자바의-미래)
- [21.5 더 빠르게 발전하는 자바](#215-더-빠르게-발전하는-자바)
- [21.6 결론](#216-결론)

### 부록

- [\_APPENDIX A 기타 언어 업데이트](#appendix-a-기타-언어-업데이트)
- [\_APPENDIX B 기타 라이브러리 업데이트](#appendix-b-기타-라이브러리-업데이트)
- [\_APPENDIX C 스트림에 여러 연산 병렬로 실행하기](#appendix-c-스트림에-여러-연산-병렬로-실행하기)
- [\_APPENDIX D 람다와 JVM 바이트코드](#appendix-d-람다와-jvm-바이트코드)

## PART V 개선된 자바 동시성

### CHAPTER 15 CompletableFuture와 리액티브 프로그래밍 컨셉의 기초

#### 15.1 동시성을 구현하는 자바 지원의 진화

#### 15.2 동기 API와 비동기 API

#### 15.3 박스와 채널 모델

#### 15.4 CompletableFuture와 콤비네이터를 이용한 동시성

#### 15.5 발행-구독 그리고 리액티브 프로그래밍

#### 15.6 리액티브 시스템 vs 리액티브 프로그래밍

#### 15.7 마치며

### CHAPTER 16 CompletableFuture : 안정적 비동기 프로그래밍

#### 16.1 Future의 단순 활용

#### 16.2 비동기 API 구현

#### 16.3 비블록 코드 만들기

#### 16.4 비동기 작업 파이프라인 만들기

#### 16.5 CompletableFuture의 종료에 대응하는 방법

#### 16.6 로드맵

#### 16.7 마치며

### CHAPTER 17 리액티브 프로그래밍

#### 17.1 리액티브 매니패스토

#### 17.2 리액티브 스트림과 플로 API

#### 17.3 리액티브 라이브러리 RxJava 사용하기

#### 17.4 마치며

## PART VI 함수형 프로그래밍과 자바 진화의 미래

### CHAPTER 18 함수형 관점으로 생각하기

#### 18.1 시스템 구현과 유지보수

#### 18.2 함수형 프로그래밍이란 무엇인가?

#### 18.3 재귀와 반복

#### 18.4 마치며

### CHAPTER 19 함수형 프로그래밍 기법

#### 19.1 함수는 모든 곳에 존재한다

#### 19.2 영속 자료구조

#### 19.3 스트림과 게으른 평가

#### 19.4 패턴 매칭

#### 19.5 기타 정보

#### 19.6 마치며

### CHAPTER 20 OOP와 FP의 조화 : 자바와 스칼라 비교

#### 20.1 스칼라 소개

#### 20.2 함수

#### 20.3 클래스와 트레이트

#### 20.4 마치며

### CHAPTER 21 결론 그리고 자바의 미래

#### 21.1 자바 8의 기능 리뷰

#### 21.2 자바 9 모듈 시스템

#### 21.3 자바 10 지역 변수형 추론

#### 21.4 자바의 미래

#### 21.5 더 빠르게 발전하는 자바

#### 21.6 결론

### 부록

#### \_APPENDIX A 기타 언어 업데이트

#### \_APPENDIX B 기타 라이브러리 업데이트

#### \_APPENDIX C 스트림에 여러 연산 병렬로 실행하기

#### \_APPENDIX D 람다와 JVM 바이트코드
