## 목차

### [1장 들어가기](#1장-들어가기)

### [2장 객체 생성과 파괴](#2장-객체-생성과-파괴)

- [아이템 1. 생성자 대신 정적 팩터리 메서드를 고려하라](#아이템-1-생성자-대신-정적-팩터리-메서드를-고려하라)
- [아이템 2. 생성자에 매개변수가 많다면 빌더를 고려하라](#아이템-2-생성자에-매개변수가-많다면-빌더를-고려하라)
- [아이템 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라](#아이템-3-private-생성자나-열거-타입으로-싱글턴임을-보증하라)
- [아이템 4. 인스턴스화를 막으려거든 private 생성자를 사용하라](#아이템-4-인스턴스화를-막으려거든-private-생성자를-사용하라)
- [아이템 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라](#아이템-5-자원을-직접-명시하지-말고-의존-객체-주입을-사용하라)
- [아이템 6. 불필요한 객체 생성을 피하라](#아이템-6-불필요한-객체-생성을-피하라)
- [아이템 7. 다 쓴 객체 참조를 해제하라](#아이템-7-다-쓴-객체-참조를-해제하라)
- [아이템 8. finalizer와 cleaner 사용을 피하라](#아이템-8-finalizer와-cleaner-사용을-피하라)
- [아이템 9. try-finally보다는 try-with-resources를 사용하라](#아이템-9-try-finally보다는-try-with-resources를-사용하라)

### [3장 모든 객체의 공통 메서드](#3장-모든-객체의-공통-메서드)

- [아이템 10. equals는 일반 규약을 지켜 재정의하라](#아이템-10-equals는-일반-규약을-지켜-재정의하라)
- [아이템 11. equals를 재정의하려거든 hashCode도 재정의하라](#아이템-11-equals를-재정의하려거든-hashcode도-재정의하라)
- [아이템 12. toString을 항상 재정의하라](#아이템-12-tostring을-항상-재정의하라)
- [아이템 13. clone 재정의는 주의해서 진행하라](#아이템-13-clone-재정의는-주의해서-진행하라)
- [아이템 14. Comparable을 구현할지 고려하라](#아이템-14-comparable을-구현할지-고려하라)

### [4장 클래스와 인터페이스](#4장-클래스와-인터페이스)

- [아이템 15. 클래스와 멤버의 접근 권한을 최소화하라](#아이템-15-클래스와-멤버의-접근-권한을-최소화하라)
- [아이템 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라](#아이템-16-public-클래스에서는-public-필드가-아닌-접근자-메서드를-사용하라)
- [아이템 17. 변경 가능성을 최소화하라](#아이템-17-변경-가능성을-최소화하라)
- [아이템 18. 상속보다는 컴포지션을 사용하라](#아이템-18-상속보다는-컴포지션을-사용하라)
- [아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라](#아이템-19-상속을-고려해-설계하고-문서화하라-그러지-않았다면-상속을-금지하라)
- [아이템 20. 추상 클래스보다는 인터페이스를 우선하라](#아이템-20-추상-클래스보다는-인터페이스를-우선하라)
- [아이템 21. 인터페이스는 구현하는 쪽을 생각해 설계하라](#아이템-21-인터페이스는-구현하는-쪽을-생각해-설계하라)
- [아이템 22. 인터페이스는 타입을 정의하는 용도로만 사용하라](#아이템-22-인터페이스는-타입을-정의하는-용도로만-사용하라)
- [아이템 23. 태그 달린 클래스보다는 클래스 계층구조를 활용하라](#아이템-23-태그-달린-클래스보다는-클래스-계층구조를-활용하라)
- [아이템 24. 멤버 클래스는 되도록 static으로 만들라](#아이템-24-멤버-클래스는-되도록-static으로-만들라)
- [아이템 25. 톱레벨 클래스는 한 파일에 하나만 담으라](#아이템-25-톱레벨-클래스는-한-파일에-하나만-담으라)

## 1장 들어가기

## 2장 객체 생성과 파괴

### 아이템 1. 생성자 대신 정적 팩터리 메서드를 고려하라

- 이름을 가질 수 있고 호출될때마다 인스턴스를 새로 생성하지 않아도 된다.
- 반환타입 하위 타입 객체를 반환할 수 있다.

### 아이템 2. 생성자에 매개변수가 많다면 빌더를 고려하라

- 인프런 강의에서도 자주 언급되는 내용

### 아이템 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라

- 원소가 하나뿐인 열거타입이 싱글턴을 만드는 가장 좋은 방법이다.

```java
public enum PRESLY {
    INSTANCE;
    public void leaveTheCity(){ ... }
}
```

### 아이템 4. 인스턴스화를 막으려거든 private 생성자를 사용하라

```java
public class Example {
    private Example() {
        throw new AssertionnError();
    }
}
```

- private으로 선언하여 하위 클래스가 상위 클래스의 생성자에 접근할 길이 막혀버렸다.

### 아이템 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

- 클래스가 하나 이상의 자원에 의존한다면 싱글턴이나 정적 유틸리티 클래스는 적합하지 않다.

### 아이템 6. 불필요한 객체 생성을 피하라

- 아이템 50과 대조 됨

### 아이템 7. 다 쓴 객체 참조를 해제하라

- 자기 메모리를 직접 관리하는 클래스라면 프로그래머는 항시 메모리누수를 주의해야 한다.

### 아이템 8. finalizer와 cleaner 사용을 피하라

- finalizer : 예측할 수 없다.
- cleaner : finalizer보다는 덜 위험하지만, 여전히 예측할 수 없고 느리다. 일반적으로 불필요하다.
- 상태를 영구적으로 수정하는 작업에서 절대 finalizer, cleaner를 의존해서는 안된다.

### 아이템 9. try-finally보다는 try-with-resources를 사용하라

- 코드가 더 짧고 분명해진다.
- 예외 정보도 훨씬 유용하다.
- 정확하고 쉽게 자원을 회수할 수 있다.

## 3장 모든 객체의 공통 메서드

### 아이템 10. equals는 일반 규약을 지켜 재정의하라

- 반사성 : null이 아닌 모든 참조 값 x에 대해, x.equals(x)는 true이다.
- 대칭성
- 추이성
- 일관성
- null 아님

### 아이템 11. equals를 재정의하려거든 hashCode도 재정의하라

- equals가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야한다.

```java
@Override
public int hashCode() {
    int res = Short.hashCode(areaCode);
    res = 31 * res + Short.hashCode(prefix);
    res = 31 * res + Short.hashCode(lineNum);
    return res;
}
```

### 아이템 12. toString을 항상 재정의하라

### 아이템 13. clone 재정의는 주의해서 진행하라

### 아이템 14. Comparable을 구현할지 고려하라

## 4장 클래스와 인터페이스

### 아이템 15. 클래스와 멤버의 접근 권한을 최소화하라

### 아이템 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

### 아이템 17. 변경 가능성을 최소화하라

### 아이템 18. 상속보다는 컴포지션을 사용하라

### 아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

### 아이템 20. 추상 클래스보다는 인터페이스를 우선하라

### 아이템 21. 인터페이스는 구현하는 쪽을 생각해 설계하라

### 아이템 22. 인터페이스는 타입을 정의하는 용도로만 사용하라

### 아이템 23. 태그 달린 클래스보다는 클래스 계층구조를 활용하라

### 아이템 24. 멤버 클래스는 되도록 static으로 만들라

### 아이템 25. 톱레벨 클래스는 한 파일에 하나만 담으라
